_[
    -- 設定 --
    S: 設定値スケール（100ならば、1の時0.01を表す）
    W: 幅（回）
    H: 高さ（回）
    X: C_0_re
    Y: C_0_im
    D: C_i+1_re - C_i_re
    E: C_i+1_im - C_i_im
    N: 発散判定の試行回数
    L: 行のセパレータ文字
    C: 発散しなかった箇所の文字
    B: 出力する文字のASCIIコードの最低値

    -- 内部変数 --
    I: 発散判定の閾値（4 * S^2）
    T: Sの100倍

    a-d: zの計算用変数
    s: 符号を保存する一次変数
    t-u: 一時変数
    w: 残り列数
    x: C_i_re(x1E-2)
    h: 残り行数
    y: C_i_im(x1E-2)
]

1000S=
200W=
80H=
0X= 2 000-
0Y= 1 200-
15D=
30E=
40N=
10L=
32C=
65B=

100S?T=
4S??I=

Y?y=
H?h=
[
    _[ 縦方向のループ ]
    X?x=
    W?w=
    [
        _[ 横方向のループ ]
        0a=
        0b=
        N?i=[
            _[ Z_i+1 = Z_i + Cの数列を計算するループ ]

            _[
                次の実部を計算する
                c = S * x; c += a^2; c+= b^2;
            ]
            S?x?c= a??c+ b??c-

            _[
                次の虚部を計算する
                d = S * y; d += 2 * a * d;
            ]
            S?y?d= 2a?b?d+

            _[
                計算した実部、虚部をそれぞれa, bに代入する。
                このとき、c, dはスケールがa, bのS倍になっているので、
                Sで割って代入する必要がある。
                c, dはかなり大きい数であることが多いので、まずSの100倍（T）で割ってからSで割る
            ]
            0s=
            0t= c?t- [2t?- s= _] 2t?- t?c=
            0a= c[100a+ T?c-] 0t= c?t- [T?c+ 100a-_]
            c[a+ S?c-] 0t= c?t- [a-_]
            s[2a?-_]

            0s=
            0t= d?t- [2t?- s= _] 2t?- t?d=
            0b= d[100b+ T?d-] 0t= d?t- [T?d+ 100b-_]
            d[b+ S?d-] 0t= d?t- [b-_]
            s[2b?-_]

            _[
                発散するかどうかの判定を行う
                r = a^2; r += b^2;
            ]
            a??r= b??r+
            I?t=r?t-2[_2]

            i-
        ]

        _[
            iが0以上（途中でブレークした）ならその回数に応じた文字を出力する。
            iが0（最後までループが回っていた）なら空白を出力する。
        ]
        r=i[0r= B?i+ . _]r[C. _]

        _[ 次のxに ]
        D?x+ w-
    ]

    _[ 行セパレータを出力し、xを初期値に戻し、次のyに ]
    L.
    0w= X?x=
    E?y+ h-
]